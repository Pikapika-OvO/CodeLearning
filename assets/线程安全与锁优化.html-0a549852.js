const e=JSON.parse('{"key":"v-dbe32478","path":"/language/java/concurrent/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html","title":"线程安全与锁优化","lang":"zh-CN","frontmatter":{"description":"线程安全与锁优化 2. 锁优化 2.1 自旋锁与自适应自旋 自旋锁（Spinning）：如果物理机器上有一个以上得处理器或处理核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的线程 “稍等一会儿”，但不放弃分配到的处理器执行时间，看看当前持有锁的线程是否会很快放弃锁。为了让线程等待而不挂起线程，我们让线程执行一个忙循环（自旋），这项技术也就是所谓的 自旋锁。 自旋锁在 JDK 1.4.2 中被引入，但是并没有默认开启，可以使用 -XX:+UseSpinning 参数来开启。不过在之后 JDK 6 中已经是默认开启状态。值得注意的是自旋等待并不能代替阻塞，暂且不说处理器数量的要求，自旋锁虽然避免了线程之前切换带来的开销，但是他要占用处理器的执行时间（CPU时间片），所以如果锁被占用的时间很短，那么自旋等待的效果就会非常好；反之如果锁被占用的时间很长，那么自旋等待只会白白浪费掉处理器执行时间，而不会做任何有价值的工作，这样会造成性能浪费。所以自旋的时间必须要一定的限制，如果自旋的次数达到一定的次数还未能获得锁，那么就应该使用传统的方式将其挂起。自旋锁默认的自旋次数是 10 次，可以通过使用 -XX:PerBlockSpin 来自行更改 。","head":[["meta",{"property":"og:url","content":"https://vuepress-theme-hope-v2-demo.mrhope.site/CodeLearning/language/java/concurrent/%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8%E4%B8%8E%E9%94%81%E4%BC%98%E5%8C%96.html"}],["meta",{"property":"og:site_name","content":"CodeLearning"}],["meta",{"property":"og:title","content":"线程安全与锁优化"}],["meta",{"property":"og:description","content":"线程安全与锁优化 2. 锁优化 2.1 自旋锁与自适应自旋 自旋锁（Spinning）：如果物理机器上有一个以上得处理器或处理核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的线程 “稍等一会儿”，但不放弃分配到的处理器执行时间，看看当前持有锁的线程是否会很快放弃锁。为了让线程等待而不挂起线程，我们让线程执行一个忙循环（自旋），这项技术也就是所谓的 自旋锁。 自旋锁在 JDK 1.4.2 中被引入，但是并没有默认开启，可以使用 -XX:+UseSpinning 参数来开启。不过在之后 JDK 6 中已经是默认开启状态。值得注意的是自旋等待并不能代替阻塞，暂且不说处理器数量的要求，自旋锁虽然避免了线程之前切换带来的开销，但是他要占用处理器的执行时间（CPU时间片），所以如果锁被占用的时间很短，那么自旋等待的效果就会非常好；反之如果锁被占用的时间很长，那么自旋等待只会白白浪费掉处理器执行时间，而不会做任何有价值的工作，这样会造成性能浪费。所以自旋的时间必须要一定的限制，如果自旋的次数达到一定的次数还未能获得锁，那么就应该使用传统的方式将其挂起。自旋锁默认的自旋次数是 10 次，可以通过使用 -XX:PerBlockSpin 来自行更改 。"}],["meta",{"property":"og:type","content":"article"}],["meta",{"property":"og:locale","content":"zh-CN"}],["meta",{"property":"og:updated_time","content":"2022-12-06T14:16:59.000Z"}],["meta",{"property":"article:author","content":"Mr.Walter"}],["meta",{"property":"article:modified_time","content":"2022-12-06T14:16:59.000Z"}],["script",{"type":"application/ld+json"},"{\\"@context\\":\\"https://schema.org\\",\\"@type\\":\\"Article\\",\\"headline\\":\\"线程安全与锁优化\\",\\"image\\":[\\"\\"],\\"dateModified\\":\\"2022-12-06T14:16:59.000Z\\",\\"author\\":[{\\"@type\\":\\"Person\\",\\"name\\":\\"Mr.Walter\\",\\"url\\":\\"https://walterxiong.github.io/CodeLearning/\\"}]}"]]},"headers":[{"level":2,"title":"2. 锁优化","slug":"_2-锁优化","link":"#_2-锁优化","children":[{"level":3,"title":"2.1 自旋锁与自适应自旋","slug":"_2-1-自旋锁与自适应自旋","link":"#_2-1-自旋锁与自适应自旋","children":[]},{"level":3,"title":"2.2 锁消除","slug":"_2-2-锁消除","link":"#_2-2-锁消除","children":[]},{"level":3,"title":"2.2 锁粗化","slug":"_2-2-锁粗化","link":"#_2-2-锁粗化","children":[]},{"level":3,"title":"2.3 轻量级锁","slug":"_2-3-轻量级锁","link":"#_2-3-轻量级锁","children":[]},{"level":3,"title":"2.4 偏向锁","slug":"_2-4-偏向锁","link":"#_2-4-偏向锁","children":[]}]}],"git":{"createdTime":1670336219000,"updatedTime":1670336219000,"contributors":[{"name":"WalterXiong","email":"xiongjun-ol@outlook.com","commits":1}]},"readingTime":{"minutes":7.34,"words":2202},"filePathRelative":"language/java/concurrent/线程安全与锁优化.md","localizedDate":"2022年12月6日","excerpt":"<h1> 线程安全与锁优化</h1>\\n<h2> 2. 锁优化</h2>\\n<h3> 2.1 自旋锁与自适应自旋</h3>\\n<p><strong>自旋锁（Spinning）：<strong>如果物理机器上有一个以上得处理器或处理核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的线程 “稍等一会儿”，但不放弃分配到的</strong>处理器执行时间</strong>，看看当前持有锁的线程是否会很快放弃锁。为了让线程等待而不挂起线程，我们让线程执行一个<strong>忙循环（自旋）</strong>，这项技术也就是所谓的 <code>自旋锁</code>。</p>\\n<p>自旋锁在 JDK 1.4.2 中被引入，但是并没有默认开启，可以使用 <code>-XX:+UseSpinning</code> 参数来开启。不过在之后 JDK 6 中已经是默认开启状态。值得注意的是自旋等待并不能代替阻塞，暂且不说处理器数量的要求，自旋锁虽然避免了线程之前切换带来的开销，但是他要占用处理器的执行时间（CPU时间片），所以如果锁被占用的时间很短，那么自旋等待的效果就会非常好；反之如果锁被占用的时间很长，那么自旋等待只会白白浪费掉处理器执行时间，而不会做任何有价值的工作，这样会造成性能浪费。所以自旋的时间必须要一定的限制，如果自旋的次数达到一定的次数还未能获得锁，那么就应该使用传统的方式将其挂起。自旋锁默认的自旋次数是 10 次，可以通过使用  <code>-XX:PerBlockSpin</code> 来自行更改 。</p>","autoDesc":true}');export{e as data};
