# 线程安全与锁优化





## 2. 锁优化

### 2.1 自旋锁与自适应自旋

**自旋锁（Spinning）：**如果物理机器上有一个以上得处理器或处理核心，能让两个或以上的线程同时并行执行，我们就可以让后面请求锁的线程 “稍等一会儿”，但不放弃分配到的**处理器执行时间**，看看当前持有锁的线程是否会很快放弃锁。为了让线程等待而不挂起线程，我们让线程执行一个**忙循环（自旋）**，这项技术也就是所谓的 `自旋锁`。

自旋锁在 JDK 1.4.2 中被引入，但是并没有默认开启，可以使用 `-XX:+UseSpinning` 参数来开启。不过在之后 JDK 6 中已经是默认开启状态。值得注意的是自旋等待并不能代替阻塞，暂且不说处理器数量的要求，自旋锁虽然避免了线程之前切换带来的开销，但是他要占用处理器的执行时间（CPU时间片），所以如果锁被占用的时间很短，那么自旋等待的效果就会非常好；反之如果锁被占用的时间很长，那么自旋等待只会白白浪费掉处理器执行时间，而不会做任何有价值的工作，这样会造成性能浪费。所以自旋的时间必须要一定的限制，如果自旋的次数达到一定的次数还未能获得锁，那么就应该使用传统的方式将其挂起。自旋锁默认的自旋次数是 10 次，可以通过使用  `-XX:PerBlockSpin` 来自行更改 。

> 默认的自旋锁次数 和 使用参数修改后的次数对于整个 Java 虚拟机都是相同的。

**自适应自旋（Adaptive Spinning）：** JDK 6 对锁的优化策略中引入了自适应自旋锁。故名思意自适应自旋意味着自旋的时间（次数）不再是固定的了，而是由：**`前一次在同一个锁上的自旋时间`** 以及 **`锁的持有者的状态`** 来决定的。比如：如果在同一个锁对象上，上一个线程刚刚成功获得过锁，并且持有锁的线程正在运行，那么虚拟机就会认为这次自旋也很有可能继续成功，从而允许自旋等待维持相对更长时间；另一种情况，如果对于某个所，自旋很少成功获得过锁，那么在后续的线程要获得这个锁时将有可能直接忽略自旋的这一过程，直接挂起以避免处理器资源被浪费。



### 2.2 锁消除

**锁消除**，是 Java 虚拟机中即使编译器在运行时检测到需要同步的代码，根本就不存在多线程共享数据竞争的问题，从而实施的对锁的消除的优化策略。锁消除的判断依据来源于 **`逃逸分析技术`** ，如果判断到在一段代码中所有在堆上的数据都不会发生逃逸从而被其他线程访问到，那么就可以把他们看作成栈中额数据对待，人认为他们是线程私有的，那么同步锁自然就不再被需要。

##### ==逃逸分析（挖坑...） // todo==



### 2.2 锁粗化

锁粗化，其实很好理解，顾名思义就是将锁变大，这里的变大指的是将锁的范围变大。比如虚拟机检测到一连串零碎的造作都在对同一个对象加锁解锁（比如加锁操作时出现再循环语句的循环体之中）那么虚拟机就会将锁同步的范围扩大到整个操作序列的外部，比如 for 开始之前到 for 开始之后。这样的话执行循环就只需要加一次锁。



### 2.3 轻量级锁

JDK 6 新加入的锁机制；名字中的 “轻量级” 是指相对使用操作系统互斥量来实现的传统锁而言是轻量的（因此使用操作系统互斥量实现的锁被称为 “重量级” 锁。值得注意的是，轻量级锁并不是用来代替重量级锁的，他的设计初衷是：在保证没有多线程竞争的前提情况下，减少传统的重量级锁使用系统级互斥量所产生的性能损耗。

要了解轻量级锁的原理，首先得对（HotSpot）虚拟机对象的内存布局有所了解才行，尤其是对象头部份。HotSpot 虚拟机对象头可分为两部分（Object Header），第一部分用于存储对象运行时的数据信息（Hash码，GC分代年龄，等等。。。），第二个部分用于存放指向方法区中对象类型数据的指针（这部分在之前的章节中专门有记录过可以看一下之前的==见第二章==）；官方称为 **“Mark World”**。

#### 轻量级锁工作（加锁）的过程：

1. 当代码即将要进入同步块儿（临界区）的时候，如果当前同步对象处于 **“未锁定”（锁标志位为：01 状态）**，那么虚拟机首先会在当前线程的栈帧中创建出一块叫 **“锁记录” （Lock Record）** 空间，用于存放此同步对象当前的 Mark World 拷贝。
2. 然后虚拟机将使用 CAS 将锁对象的 Mark World 更新为指向 Lock Record 的指针。
    - 如果这个更新操作成功了，就代表当前线程获取到了该对象的锁，此时对象 Mark World 的锁标志位将转变成 **“00”（轻量级锁定状态）**，表示此时该对象进入轻量级锁定状态。
    - 如果这个更新动作失败了，表示存在一条线程与当前线程竞争获取该对象的锁，这个时候虚拟机首先会检查该对象的 Mark World 是否已经指向了当前线程的 Lock Record，如果是，表示当前线程已经拥有了该对象的锁，直接进入同步区域即可。否则就说明这个对象的锁已经被其他线程抢占了。
3. 如果出现两条以上的线程争抢同一个锁的情况，那么轻量级锁就不再有效了，必须要膨胀为重量级锁，所标志的状态的值变更为 **“10（重量级锁定状态）”**，此时对象 Mark World 中存储的就是指向重量级锁（互斥量）的指针，而后面等待锁的线程都必须进入阻塞状态。

轻量级锁的解锁过程也是使用 CAS 实现的，如果代码即将出同步块儿时，如果对象的 Mark World 任然指向线程的 Lock Record ，那么虚拟机通过 CSA 尝试将对象的 Mark World 和线程中的 Displaced Mark World 拷贝，互换过来，如果成功了那么整个同步的工作就顺利的完成了；反之如果替换失败了，那证明有其他线程尝试获取过对象的锁，那么就要在释放锁的同时，唤醒被挂起阻塞等待的线程。

小结一下：

更具书中所说，轻量级锁提升程序同步性能的依据是：“对于绝大部分的锁来说，在整个同步周期内都是不存在竞争的”，这是个经验法则，那么假设：

- 如果没有竞争的情况下，轻量级锁通多 CAS 能够很好的屏蔽掉使用操作系统互斥量的锁带来的开销，确实是提升了同步的性能；
- 但是存在竞争的情况下，除了互斥量的开销之外，还有发生 CAS 带来的开销，反而更加的 “笨重”；

因此，在存在竞争的情况下，轻量级锁反而会比传统的重量级锁更慢。



### 2.4 偏向锁

偏向锁也还是 JDK 6 引入的锁优化策略。在 2020 年 9 月15日发布的 JDK 15（ 详情见 [JDK 15 官方计划](https://link.segmentfault.com/?enc=yu9gxXnWP2rmvp1Kou9qXA%3D%3D.W8%2Bb6jUGiqfmD3kOs6%2FUUQEGJSSJs2dJckSNND0wvtd3uvqmB518HP2Zr4hsQbJj) ）其中有一项更新是 `废弃偏向锁`，官方的详细说明在：[JEP 374: Disable and Deprecate Biased Locking](https://link.segmentfault.com/?enc=sMy%2FbWLIS0HjMriGVdmH7Q%3D%3D.m4Vh76y78uXaeyiDOpdwE1TloZqJnvrmHQqf47krMA7dXCInsVHTSxronHOzKiKf)，原因是偏向锁的维护成本过于高昂。

那么了解偏向锁之前我想大家对 synchronized 关键字应该并不陌生。synchronized 是我们解决多线程并发情况下数据同步访问的一把利刃，更多的时候我们只掌握了如何使用它，但是并不知道它的原理是什么，接下来我们就分层去剖析一下这个同步关键字。



